import d from 'debug';
import assert from 'assert';
import EventEmitter from 'events';
import { sortBy } from 'lodash';
import File from './models/File';

const debug = d('docs:cache');

/**
 * Stores compiled documents, and allows them to be accessed by path, filename, or URL.
 * Tracks dependencies between documents and recompiles them as necessary when files change.
 */
class Cache extends EventEmitter {

  /**
   * Creates a Cache.
   * @param {Object} options - An options hash.
   * @param {Compiler} options.compiler - A Compiler instance.
   * @param {Watcher} options.watcher - A Watcher instance.
   * @param {Function} [options.isArticle] - A filter function to test if a file is an article.
   * @param {Object} [options.reducers] - A hash of reducers to attach to the cache.
   */
  constructor(options = {}) {
    super();
    assert(options.compiler, 'Cache constructor requires a compiler option');
    assert(options.watcher, 'Cache constructor requires a watcher option');
    this.compiler = options.compiler;
    this.watcher = options.watcher;
    this.isArticle = options.isArticle || Cache.defaults.isArticle;
    this.reducers = options.reducers || {};
    this.reductions = {};
    this.docsByPath = {};
    this.docsByFilename = {};
    this.docsByUrl = {};
    this.pendingCallbacks = [];
    this.isReady = false;
    this.watcher.on('add', this.handleFileAdded.bind(this));
    this.watcher.on('change', this.handleFileChanged.bind(this));
    this.watcher.on('ready', this.handleWatcherReady.bind(this));
  }

  /**
   * Adds a document to the Cache.
   * @param {Document} doc - The document to add.
   */
  add(doc) {
    debug(`[add] ${doc.path} (${doc.shortname})`);
    this.docsByPath[doc.path] = doc;
    this.docsByFilename[doc.filename] = doc;
    this.docsByUrl[doc.url] = doc;
    this.emit('add', doc);
  }

  /**
   * Returns the value generated by the reducer with the specified name. If no such
   * reducer has been registered, an Error will be thrown. If the reduction has
   * not yet been processed, all reductions will be processed.
   * @param {String} name - The name of the reduction to return.
   * @returns The value of the reduction.
   */
  getReduction(name) {
    if (!this.reducers[name]) {
      throw new Error(`No reduction named ${name} has been registered on the Cache`);
    }
    if (!this.reductions[name]) this.processReductions();
    return this.reductions[name];
  }

  /**
   * Renders the content for all documents that have been loaded.
   */
  warm() {
    Object.keys(this.docsByPath)
    .forEach(path => {
      const doc = this.docsByPath[path];
      doc.getContent();
    });
  }

  /**
   * Return the document in the cache with the specified path relative to the baseDir,
   * or throws an Error if no such document exists.
   * @param {string} path - The path to match.
   * @returns {Document} The document document with the specified path.
   */
  get(path) {
    const doc = this.tryGet(path);
    if (!doc) throw new Error(`No document with the path ${path} exists in the cache`);
    return doc;
  }

  /**
   * Return the document in the cache with the specified path relative to the baseDir.
   * @param {string} path - The path to match.
   * @returns {Document} The document, or undefined if no match was found.
   */
  tryGet(path) {
    return this.docsByPath[path];
  }

  /**
   * Return the document in the cache with the specified (absolute) filename.
   * @param {string} filename - The filename to match.
   * @returns {Document} The document, or undefined if no match was found.
   */
  getByFilename(filename) {
    return this.docsByFilename[filename];
  }

  /**
   * Return the document in the cache with the specified URL.
   * @param {string} url - The URL to match.
   * @returns {Document} The document, or undefined if no match was found.
   */
  getByUrl(url) {
    const normalizedUrl = (url[0] === '/') ? url : `/${url}`;
    return this.docsByUrl[normalizedUrl];
  }

  /**
   * Return all documents whose path begin with the specified string.
   * @param {string} query - The string to search for.
   * @param {Object} [options] - An options hash.
   * @param {string} [options.sort] - The metadata property to sort the documents by.
   */
  find(query, options = {}) {
    let docs = Object.keys(this.docsByPath)
    .filter(path => path.indexOf(query) === 0)
    .map(path => this.docsByPath[path]);
    if (options.sort) docs = sortBy(docs, options.sort);
    return docs;
  }

  /**
   * Executes the specified function once for each document in the cache.
   * @param {Function} func - The function to execute.
   */
  forEach(func) {
    Object.keys(this.docsByPath).forEach(path => {
      func(this.docsByPath[path]);
    });
  }

  /**
   * Calls the specified function once the Cache is ready (once its watcher
   * has fired its ready event). If the Cache is already ready, the function
   * will be called immediately.
   * @param {Function} func - The function to call.
   */
  whenReady(func) {
    if (this.isReady) {
      func();
    } else {
      this.pendingCallbacks.push(func);
    }
  }

  /**
   * Returns an object describing the current state of the Cache, including the
   * number of documents it contains and the reductions that have been registered.
   * @returns A statistics object.
   */
  getStats() {
    return {
      count: Object.keys(this.docsByPath).length,
      reductions: Object.keys(this.reducers)
    };
  }

  /**
   * Processes all registered reductions and stores their values.
   * @private
   */
  processReductions() {
    Object.keys(this.reducers).forEach(name => {
      debug(`[reduce] Processing reduction ${name}`);
      this.reductions[name] = this.reducers[name].reduce(this);
    });
  }

  /**
   * Called when the Watcher finds a new file. If the file represents an article,
   * compiles it into a Document and adds it to the cache.
   * @param {File} file - The file that was discovered.
   */
  handleFileAdded(file) {
    if (this.isArticle(file)) {
      const doc = this.compiler.compile(file, this);
      this.add(doc);
    }
  }

  /**
   * Called when the Watcher detects a change to a previously-discovered file.
   * If the file has any dependencies that are Documents, each will be recompiled
   * and re-added to the cache.
   * @param {File} changedFile - The file that was changed.
   */
  handleFileChanged(changedFile) {
    const deps = Object.keys(this.docsByFilename)
      .filter(filename => this.docsByFilename[filename].hasDependency(changedFile.filename));

    debug(
      `[change] ${changedFile.shortname} (${deps.length} dependencies)\n` +
      deps.map(filename => `  + ${filename}`).join('\n')
    );

    const docs = deps.map(filename => {
      const file = this.watcher.load(filename);
      const doc = this.compiler.compile(file, this);
      this.add(doc);
      return doc;
    });

    this.processReductions();
    this.emit('sync', docs);
  }

  /**
   * Called when the Watcher completes its initial scan. Processes the initial
   * value for all reductions.
   */
  handleWatcherReady() {
    this.processReductions();
    this.isReady = true;
    this.pendingCallbacks.forEach(func => func());
    this.pendingCallbacks = [];
    this.emit('ready');
  }

}

Cache.defaults = {
  isArticle: (file) => (
    /^articles/.test(file.shortname) &&
    !file.shortname.split('/').some(segment => /^_/.test(segment))
  )
};

export default Cache;
